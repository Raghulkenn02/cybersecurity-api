# Import necessary libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow import keras
from tensorflow.keras import layers
import os

# Print current working directory
print("Current working directory:", os.getcwd())

# Load the dataset with an absolute path
data = pd.read_csv(r"C:\Users\rakes\OneDrive\Desktop\Raghul\Clg\Dissertation\Datasets\Preprocessed data\preprocessed_phishing_data.csv")
  # Adjust the path to your dataset

# Preprocess the data
X = data.drop('label', axis=1)  # Assuming 'label' is the target column
y = data['label']

# Check for NaN values and drop them
if X.isnull().values.any() or y.isnull().values.any():
    print("NaN values found. Dropping NaN values.")
    X = X.dropna()
    y = y[X.index]  # Ensure y is aligned with X

# Check the unique values in the target variable
print("Unique values in target variable:", y.unique())

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalize the features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Build the neural network model with a simpler architecture
model = keras.Sequential([
    layers.Input(shape=(X_train.shape[1],)),  # Input layer
    layers.Dense(32, activation='relu'),  # First hidden layer
    layers.Dropout(0.2),  # Dropout for regularization
    layers.Dense(16, activation='relu'),  # Second hidden layer
    layers.Dense(1, activation='sigmoid')  # Output layer for binary classification
])

# Compile the model with a lower learning rate
model.compile(optimizer=keras.optimizers.Adam(learning_rate=0.0001), 
              loss='binary_crossentropy', 
              metrics=['accuracy'])

# Train the model
history = model.fit(X_train, y_train, 
                    epochs=20, 
                    batch_size=32, 
                    validation_split=0.2)

# Evaluate the model
test_loss, test_accuracy = model.evaluate(X_test, y_test)
print(f'Test Loss: {test_loss}, Test Accuracy: {test_accuracy}')

# Save the model in the Keras format
model.save('phishing_detection_model.keras')

# Optionally, you can plot the training history
import matplotlib.pyplot as plt

# Plot training & validation accuracy values
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(loc='upper left')

# Plot training & validation loss values
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(loc='upper left')

plt.tight_layout()
plt.show()